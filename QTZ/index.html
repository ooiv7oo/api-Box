<!DOCTYPE html>
<html>
<head>
  <title>Force jump to QQ</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* 响应式设计 */
    @media (max-width: 768px) {
      /* 移动端样式 */
      body {
        font-size: 16px;
      }
    }
    @media (min-width: 769px) {
      /* PC 端样式 */
      body {
        font-size: 20px;
      }
    }
    #canvas{
      position:fixed;
      bottom:20%;
      left:50%;
      transform:translateX(-50%);
      width:100%;
      height:100%;
    }
  </style>
</head>
<body>
  <h1>Welcome</h1>
  <p id="device-info">This is a tip.</p>
  <canvas id="canvas"></canvas>
  
  <script>
    const isMobile = 'ontouchstart' in window;
    const deviceInfo = document.getElementById('device-info');
    deviceInfo.textContent = isMobile ? 'Your current device is a mobile device, which can be called by touching it.' : 'Your current device is on the PC side and is being called.';

    function generateProfileCard() {
      const qq = new URLSearchParams(window.location.search).get('qq');
      if (!qq) {
        alert('参数不能为空！');
        return;
      }
      const url = `mqq://card/show_pslcard?src_type=internal&source=sharecard&version=1&uin=${qq}`;
      window.location.href = url;
      setTimeout(function() {
        window.opener = null;
        window.close();
      }, 600);
    }

    function retryGenerateProfileCard(maxAttempts, delay) {
      let attempts = 0;
      function tryGenerateProfileCard() {
        attempts++;
        try {
          generateProfileCard();
          console.log('Function executed successfully!');
        } catch (error) {
          console.error('Function execution failed. Attempt #' + attempts + '. Error: ' + error.message);
          if (attempts < maxAttempts) {
            console.log('Retrying in ' + delay + ' milliseconds...');
            setTimeout(tryGenerateProfileCard, delay);
          } else {
            console.error('Max number of attempts exceeded. Giving up.');
          }
        }
      }
      tryGenerateProfileCard();
    }

    if (isMobile) {
      document.addEventListener('touchstart', function() {
        retryGenerateProfileCard(3, 1000);
      });
    } else {
      window.onload = function() {
        retryGenerateProfileCard(3, 1000);
      };
    }
    // 获取canvas元素和WebGL上下文
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');

// 定义顶点和片元着色器代码
const vertexShaderSource = `
    attribute vec3 a_position;

    uniform mat4 u_matrix;
    uniform float u_size;

    void main() {
        gl_Position = u_matrix * vec4(a_position * u_size, 1.0);
    }
`;

const fragmentShaderSource = `
    precision mediump float;

    uniform float u_time;

    void main() {
        float t = u_time * 0.1;
        float x = gl_FragCoord.x / 200.0;
        float y = gl_FragCoord.y / 200.0;
        float r = sqrt(x * x + y * y);
        float theta = atan(y, x);
        float dx = 0.1 * sin(theta * 5.0 + t);
        float dy = 0.1 * cos(theta * 5.0 + t);
        float dr = 0.1 * sin(r * 5.0 + t);
        float u = x + dx + dr;
        float v = y + dy + dr;
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        gl_FragColor.rgb += 0.5 * sin(u * 50.0 + t);
        gl_FragColor.rgb += 0.2 * sin(u * 100.0 + v * 100.0 + t);
        gl_FragColor.rgb += 0.1 * sin(r * 100.0 + t);
    }
`;

// 创建顶点着色器
const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, vertexShaderSource);
gl.compileShader(vertexShader);

if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    console.error('Vertex shader compile error:', gl.getShaderInfoLog(vertexShader));
}

// 创建片元着色器
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, fragmentShaderSource);
gl.compileShader(fragmentShader);

if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    console.error('Fragment shader compile error:', gl.getShaderInfoLog(fragmentShader));
}

// 创建着色器程序
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
}

gl.useProgram(program);

// 获取顶点位置属性和uniform变量
const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
const matrixUniformLocation = gl.getUniformLocation(program, 'u_matrix');
const sizeUniformLocation = gl.getUniformLocation(program, 'u_size');
const timeUniformLocation = gl.getUniformLocation(program, 'u_time');

// 定义顶点数据
const positions = [
    -1, -1, 0,
    -1, 1, 0,
    1, 1, 0,
    1, -1, 0
];

// 创建顶点缓冲区
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

// 设置顶点属性指针
gl.enableVertexAttribArray(positionAttributeLocation);
gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

// 设置视口和清空颜色
gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(1.0, 1.0, 1.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// 设置矩阵和大小
const matrix = new Float32Array([
    2.0 / canvas.width, 0.0, 0.0, 0.0,
    0.0, -2.0 / canvas.height, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    -1.0, 1.0, 0.0, 1.0
]);
gl.uniformMatrix4fv(matrixUniformLocation, false, matrix);
gl.uniform1f(sizeUniformLocation, canvas.width * 0.5);

// 定义动画循环函数
function animate(time) {
    // 清空颜色缓冲区
    gl.clear(gl.COLOR_BUFFER_BIT);

    // 更新时间uniform变量
    gl.uniform1f(timeUniformLocation, time);

    // 绘制小球
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

    // 循环调用动画函数
    requestAnimationFrame(animate);
}

// 启动动画循环
requestAnimationFrame(animate);
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>Force jump to QQ</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* 响应式设计 */
    @media (max-width: 768px) {
      /* 移动端样式 */
      body {
        font-size: 16px;
      }
    }
    @media (min-width: 769px) {
      /* PC 端样式 */
      body {
        font-size: 20px;
      }
    }
    #canvas {
    position: fixed;
    bottom: 30%;
    left: 50%;
    transform: translateX(-50%);
}
  </style>
</head>
<body>
  <h1>Welcome</h1>
  <p id="device-info">This is a tip.</p>
  <canvas id="canvas"></canvas>
  
  <script>
    const isMobile = 'ontouchstart' in window;
    const deviceInfo = document.getElementById('device-info');
    deviceInfo.textContent = isMobile ? 'Your current device is a mobile device, which can be called by touching it.' : 'Your current device is on the PC side and is being called.';

    function generateProfileCard() {
      const qq = new URLSearchParams(window.location.search).get('qq');
      if (!qq) {
        alert('参数不能为空！');
        return;
      }
      const url = `mqq://card/show_pslcard?src_type=internal&source=sharecard&version=1&uin=${qq}`;
      window.location.href = url;
      setTimeout(function() {
        window.opener = null;
        window.close();
      }, 600);
    }

    function retryGenerateProfileCard(maxAttempts, delay) {
      let attempts = 0;
      function tryGenerateProfileCard() {
        attempts++;
        try {
          generateProfileCard();
          console.log('Function executed successfully!');
        } catch (error) {
          console.error('Function execution failed. Attempt #' + attempts + '. Error: ' + error.message);
          if (attempts < maxAttempts) {
            console.log('Retrying in ' + delay + ' milliseconds...');
            setTimeout(tryGenerateProfileCard, delay);
          } else {
            console.error('Max number of attempts exceeded. Giving up.');
          }
        }
      }
      tryGenerateProfileCard();
    }

    if (isMobile) {
      document.addEventListener('touchstart', function() {
        retryGenerateProfileCard(3, 1000);
      });
    } else {
      window.onload = function() {
        retryGenerateProfileCard(3, 1000);
      };
    }
    
    // 获取canvas元素和WebGL上下文
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');

// 定义顶点和片元着色器代码
const vertexShaderSource = `
    attribute vec3 a_position;

    uniform mat4 u_matrix;
    uniform float u_size;

    void main() {
        gl_Position = u_matrix * vec4(a_position * u_size, 1.0);
    }
`;

const fragmentShaderSource = `
    precision mediump float;

    uniform float u_time;

    void main() {
        float t = u_time * 0.1;
        float x = gl_FragCoord.x / 200.0;
        float y = gl_FragCoord.y / 200.0;
        float r = sqrt(x * x + y * y);
        float theta = atan(y, x);
        float dx = 0.1 * sin(theta * 5.0 + t);
        float dy = 0.1 * cos(theta * 5.0 + t);
        float dr = 0.1 * sin(r * 5.0 + t);
        float u = x + dx + dr;
        float v = y + dy + dr;
        gl_FragColor = vec4(u, v, u * v, 1.0);
    }
`;

// 创建顶点着色器
const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, vertexShaderSource);
gl.compileShader(vertexShader);

if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
    console.error('Error compiling vertex shader:', gl.getShaderInfoLog(vertexShader));
}

// 创建片元着色器
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, fragmentShaderSource);
gl.compileShader(fragmentShader);

if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
    console.error('Error compiling fragment shader:', gl.getShaderInfoLog(fragmentShader));
}

// 创建着色器程序
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Error linking program:', gl.getProgramInfoLog(program));
}

// 使用着色器程序
gl.useProgram(program);

// 获取顶点属性位置
const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');

// 创建顶点缓冲区
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// 定义顶点数据
const positions = [
    0.0, 0.0, 0.0,
    0.0, 1.0, 0.0,
    1.0, 1.0, 0.0,
    1.0, 0.0, 0.0,
];

// 将顶点数据写入缓冲区
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

// 启用顶点属性
gl.enableVertexAttribArray(positionAttributeLocation);

// 告诉WebGL如何从缓冲区中读取顶点数据
gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

// 获取uniform变量位置
const matrixUniformLocation = gl.getUniformLocation(program, 'u_matrix');
const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
const sizeUniformLocation = gl.getUniformLocation(program, 'u_size');

// 定义投影矩阵
const fov = 60 * Math.PI / 180;
const aspect = canvas.clientWidth / canvas.clientHeight;
const zNear = 0.1;
const zFar = 100.0;
const projectionMatrix = mat4.create();
mat4.perspective(projectionMatrix, fov, aspect, zNear, zFar);

// 定义模型视图矩阵
const modelViewMatrix = mat4.create();

// 定义缩放矩阵
const scaleMatrix = mat4.create();

function draw() {
    // 获取画布的宽度和高度
    const canvasWidth = canvas.clientWidth;
    const canvasHeight = canvas.clientHeight;

    // 计算小球的大小
    const ballSize = Math.min(canvasWidth, canvasHeight) * 0.5;

    // 设置画布的实际大小
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // 设置视口大小
    gl.viewport(0, 0, canvasWidth, canvasHeight);

    // 清空画布
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // 设置模型视图矩阵
    mat4.identity(modelViewMatrix);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -3.0]);

    // 设置缩放矩阵
    mat4.identity(scaleMatrix);
    mat4.scale(scaleMatrix, scaleMatrix, [ballSize, ballSize, ballSize]);

    // 将投影矩阵、模型视图矩阵和缩放矩阵相乘，得到最终的变换矩阵
    const matrix = mat4.create();
    mat4.multiply(matrix, projectionMatrix, modelViewMatrix);
    mat4.multiply(matrix, matrix, scaleMatrix);

    // 设置uniform变量的值
    gl.uniformMatrix4fv(matrixUniformLocation, false, matrix);
    gl.uniform1f(timeUniformLocation, performance.now() / 1000);
    gl.uniform1f(sizeUniformLocation, ballSize);

    // 绘制小球
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

    // 请求下一帧动画
    requestAnimationFrame(draw);
}

// 开始绘制动画
requestAnimationFrame(draw);
  </script>
</body>
</html>
